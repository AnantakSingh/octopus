<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Higher or Lower — p5.js</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.11.10/lib/p5.js"></script>
<script src="https://cdn.jsdelivr.net/npm/p5@1.11.10/lib/addons/p5.sound.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitcount+Grid+Single:wght@100..900&display=swap" rel="stylesheet">

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Bitcount Grid Single';
    overflow: hidden;
    color: #fff;
  }

  #bg-container {
    position: fixed;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 0;
  }

  .site-thumb {
    flex: 1;
    height: 100%;
    background-size: cover;
    background-position: center;
    transition: filter 0.4s ease;
    filter: brightness(10%);
  }

  .site-thumb.locked {
    filter: brightness(10%);
  }

  .site-thumb.unlocked {
    filter: brightness(100%);
  }

  #game-box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    display: flex;
    gap: 20px;
    align-items: center;
    background: rgba(0, 0, 0, 0.4);
    padding: 10px 10px;
    border-radius: 10px;
  }

  #canvas-holder {
    position: relative;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: center;
  }

  button {
    font-family: 'Bitcount Grid Single';
    font-size: 20px;
    padding: 10px 10px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    background: rgba(0,0,0);
    color: rgba(255,255,255);
    box-shadow: 0 6px rgba(0,0,0,0.3);
  }
  button:active {
    transform: translateY(2px);
  }
</style>
</head>
<body>

  <div id="bg-container">
    <div class="site-thumb locked" id="thumb0" data-link="sketch1.html" style="background-image:url('img1.png')"></div>
    <div class="site-thumb locked" id="thumb1" data-link="sketch2.html" style="background-image:url('img2.png')"></div>
    <div class="site-thumb locked" id="thumb2" data-link="sketch3.html" style="background-image:url('img3.png')"></div>
  </div>

  <div id="game-box">
    <div id="canvas-holder"></div>
    <div class="controls">
      <div>
        <button id="hB">HIGHER</button>
        <button id="lB">LOWER</button>
      </div>
    </div>
  </div>

<script>
let suits = ['S','H','D','C'];
let values = [
  {label:'A', value:14},{label:'2', value:2},{label:'3', value:3},
  {label:'4', value:4},{label:'5', value:5},{label:'6', value:6},
  {label:'7', value:7},{label:'8', value:8},{label:'9', value:9},
  {label:'10', value:10},{label:'J', value:11},{label:'Q', value:12},{label:'K', value:13}
];

let deck = [];
let deckX, deckY;
let cardW = 120, cardH = 170;
let cardfan = 0.6;
let topIndex;
let currentCard = null;
let anim = null;
let busy = false;
let wins = 0;
let unlockedCount = 0;
const maxUnlock = 3;
const thumbs = [];
let animCallback = null;

let backImg;

let suitImages = {};

function preload() {
  backImg = loadImage('cardback.png');
  suitImages['S'] = loadImage('spades.png');
  suitImages['H'] = loadImage('hearts.png');
  suitImages['D'] = loadImage('diamonds.png');
  suitImages['C'] = loadImage('clubs.png');
}

function setup() {
  const holder = document.getElementById('canvas-holder');
  const cnv = createCanvas(600, 300);
  cnv.parent('canvas-holder');
  textFont('Bitcount Grid Single');
  rectMode(CENTER);

  deckX = width/2 + 80;
  deckY = height/2;

  buildDeck();
  shuffle(deck, true);
  topIndex = deck.length - 1;

  anim = {
    type: 'initialMove',
    progress: 0,
    duration: 1000,
    startTime: millis(),
  };

  document.getElementById('hB').onclick = () => buttonPressed('higher');
  document.getElementById('lB').onclick = () => buttonPressed('lower');

  for (let i=0;i<maxUnlock;i++){
    thumbs[i] = document.getElementById('thumb' + i);
    thumbs[i].addEventListener('click', ()=>{
      if (i < unlockedCount) window.open(thumbs[i].dataset.link, '_blank');
    });
  }

}

function draw() {
  clear(); 
  push();
  translate(deckX, deckY);
  for (let i = 0; i < deck.length; i++) {
    const dx = i * cardfan;
    const dy = i * cardfan;
    drawCardBack(dx, dy);
  }
  pop();

  if (currentCard) {
    push();
    translate(deckX - 200, deckY);
    drawCardFace(currentCard, 0, 0, 1);
    pop();
  }

  if (anim) handleAnimation();
}

function drawCardBack(x, y) {
  push();
  translate(x, y);
  imageMode(CENTER);
  image(backImg, 0, 0, cardW, cardH, 5);
  pop();
}



function drawCardFace(card, x, y, scaleX = 1) {
  push();
  translate(x, y);
  scale(scaleX, 1); // used during flip animations
  rectMode(CENTER);

  //Card Bg
  stroke(0);
  strokeWeight(0);
  fill(255);
  rect(0, 0, cardW, cardH, 5);

  //Card Value 
  noStroke();
  textAlign(CENTER, CENTER);
  textSize(60);
  fill(card.faceColor);
  text(card.label, 0, -cardH / 4); 

  //Card Suit
  imageMode(CENTER);
  image(suitImages[card.suit], 0, cardH / 4, 50, 50);

  pop();
}


function buildDeck() {
  deck = [];
  for (const s of suits) {
    for (const v of values) {
      let faceColor;

      if (s === 'H' || s === 'D') {
        faceColor = color(255, 0, 0, 255);
      } else {
        faceColor = color(0, 0, 0, 255); 
      }

      deck.push({
        suit: s,
        label: v.label,
        value: v.value,
        faceColor: faceColor,
      });
    }
  }
}

// Fisher-Yates shuffle algorithm for mixing the deck only once at initialization
function shuffle(array, mutate = false) {
  let arr;

  if (mutate) {
    arr = array; // modify the original array
  } else {
    arr = array.slice(); // make a copy to shuffle
  }

  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }

  if (!mutate) {
    return arr; 
  }
}


function handleAnimation(){
  const now = millis();

  if (anim.type === 'initialMove') {
    const t = (now - anim.startTime) / anim.duration;
    const drawX = lerp(deckX, deckX - 200);
    push(); translate(drawX, deckY); drawCardBack(0, 0); pop();
    if (t >= 1) {
      anim = {type:'flipIn', startTime: now, duration: 600};
      currentCard = deck.pop();
      topIndex = deck.length - 1;
    }

  } 
  
  else if (anim.type === 'flipIn') {
  const t = (now - anim.startTime) / anim.duration;
  const c = constrain(t, 0, 1);

  // Smoothly scale X from 1 → 0 → 1 (no midpoint check)
  let scaleX = abs(map(c, 0, 1, -1, 1));

  push();
  translate(deckX - 220, deckY);

  // Switch from back to face when scale is very small
    if (c < 0.5) {
      drawCardBack(0, 0);
    } else {
      drawCardFace(currentCard, 0, 0, scaleX);
    }

  pop();
  if (c >= 1) anim = null;
  }
  
  else if (anim.type === 'flipNext') {
  const { startPos, endPos, cardObj, startTime, duration } = anim;
  const t = (now - startTime) / duration;
  const c = constrain(t, 0, 1);

  const mx = lerp(startPos.x, endPos.x, c);
  const my = lerp(startPos.y, endPos.y, c) - 20 * sin(PI * c);

  let scaleX;
  if (c < 0.5) {
    scaleX = map(c, 0, 0.5, 1, 0.01);
  } else {
    scaleX = map(c, 0.5, 1, 0.01, 1);
  }

  push();
  translate(mx, my);

  // draw the card back or face based on c
  if (c < 0.5) {
    drawCardBack(0, 0);
  } else {
    drawCardFace(cardObj, 0, 0, scaleX);
  }

  pop();

  if (c >= 1) {
    currentCard = cardObj;
    anim = null;
    busy = false;
    if (animCallback) {
      animCallback();
      animCallback = null;
    }
  }
  }
}

function buttonPressed(choice) {

  if (!currentCard) return;
  if (deck.length === 0) { restartGame(); return; }

  const nextCard = deck.pop();
  topIndex = deck.length - 1;
  busy = true;

  const prevCard = currentCard;

  const startPos = {x: deckX, y: deckY};
  const endPos = {x: deckX - 200, y: deckY};
  anim = {type:'flipNext', startPos, endPos, cardObj: nextCard, startTime: millis(), duration: 700};

  animCallback = () => gameLogic(choice, prevCard, nextCard);
}

function gameLogic(choice, oldCard, newCard) {
  let correct = false;
  if (newCard.value === oldCard.value) correct = false;
  else if (choice === 'higher') correct = newCard.value > oldCard.value;
  else correct = newCard.value < oldCard.value;

  if (correct) {
    wins++;
    unlockNext();
  } else {
    wins = 0;
    lockAllSites();
  }

  if (deck.length === 0) restartGame();
}

function unlockNext(){
  if (unlockedCount < maxUnlock) {
    thumbs[unlockedCount].classList.remove('locked');
    thumbs[unlockedCount].classList.add('unlocked');
    unlockedCount++;
  }
}

function lockAllSites(){
  unlockedCount = 0;
  for (let i=0;i<maxUnlock;i++){
    thumbs[i].classList.remove('unlocked');
    thumbs[i].classList.add('locked');
  }
}

function restartGame(){
  buildDeck();
  shuffle(deck, true);
  topIndex = deck.length - 1;
  currentCard = null;
  anim = {type:'initialMove', startTime: millis(), duration: 1000};
  lockAllSites();
}

</script>
</body>
</html>
