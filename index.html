<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Higher or Lower — p5.js</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitcount+Grid+Single:wght@100..900&display=swap" rel="stylesheet">

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Bitcount Grid Single';
    overflow: hidden;
    color: #fff;
  }

  /* === BACKGROUND IMAGES === */
  #bg-container {
    position: fixed;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 0; /* behind everything else */
  }

  .site-thumb {
    flex: 1;
    height: 100%;
    background-size: cover;
    background-position: center;
    transition: filter 0.4s ease;
    cursor: pointer;
    filter: brightness(25%);
  }

  .site-thumb.locked {
    filter: brightness(25%);
    cursor: default;
  }

  .site-thumb.unlocked {
    filter: brightness(100%);
  }

  /* === GAME CONTAINER === */
  #game-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    display: flex;
    gap: 40px;
    align-items: center;
    background: rgba(0, 0, 0, 0.65);
    padding: 30px 50px;
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  }

  /* h2 {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    z-index: 6;
  } */

  #canvas-holder {
    position: relative;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: center;
  }

  button {
    font-size: 18px;
    padding: 10px 18px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    background: #4aa0d9;
    color: white;
    box-shadow: 0 6px rgba(0,0,0,0.3);
  }
  button:active {
    transform: translateY(2px);
    box-shadow: 0 3px rgba(0,0,0,0.35);
  }

  .note {
    font-size: 14px;
    color: #cfe8f1;
  }

  #message {
    min-height: 22px;
    margin-top: 6px;
  }
</style>
</head>
<body>

  <!-- === FULLSCREEN BACKGROUND IMAGES === -->
  <div id="bg-container">
    <div class="site-thumb locked" id="thumb0" data-link="sketch1.html" style="background-image:url('img1.png')"></div>
    <div class="site-thumb locked" id="thumb1" data-link="sketch2.html" style="background-image:url('img2.png')"></div>
    <div class="site-thumb locked" id="thumb2" data-link="sketch3.html" style="background-image:url('img3.png')"></div>
  </div>

  <!-- === GAME OVERLAY === -->
  <h2>Higher or Lower — p5.js</h2>
  <div id="game-container">
    <div id="canvas-holder"></div>

    <div class="controls">
      <div>
        <button id="higherBtn">Higher</button>
        <button id="lowerBtn">Lower</button>
      </div>
      <div class="note">Wins in a Row: <span id="wins">0</span></div>
      <div id="message"></div>
    </div>
  </div>

<script>
let suits = ['♠','♥','♦','♣'];
let values = [
  {label:'A', value:14},{label:'2', value:2},{label:'3', value:3},
  {label:'4', value:4},{label:'5', value:5},{label:'6', value:6},
  {label:'7', value:7},{label:'8', value:8},{label:'9', value:9},
  {label:'10', value:10},{label:'J', value:11},{label:'Q', value:12},{label:'K', value:13}
];

let deck = [];
let deckX, deckY;
let cardW = 120, cardH = 170;
let offsetStep = 0.6;
let topIndex;
let currentCard = null;
let anim = null;
let busy = false;
let wins = 0;
let unlockedCount = 0;
const maxUnlock = 3;
const thumbs = [];
let animCallback = null;

let backImg; // global variable for the card back image

let suitImages = {};

function preload() {
  backImg = loadImage('cardback.png'); // path to your image
  suitImages['♠'] = loadImage('spades.png');
  suitImages['♥'] = loadImage('hearts.png');
  suitImages['♦'] = loadImage('diamonds.png');
  suitImages['♣'] = loadImage('clubs.png');
}

function setup() {
  const holder = document.getElementById('canvas-holder');
  const cnv = createCanvas(700, 400);
  cnv.parent('canvas-holder');
  textFont('Bitcount Grid Single');
  rectMode(CENTER);

  deckX = width/2 + 100;
  deckY = height/2;

  buildDeck();
  shuffle(deck, true);
  topIndex = deck.length - 1;

  anim = {
    type: 'initialMove',
    progress: 0,
    duration: 1000,
    startTime: millis(),
  };

  document.getElementById('higherBtn').onclick = () => tryGuess('higher');
  document.getElementById('lowerBtn').onclick = () => tryGuess('lower');

  for (let i=0;i<maxUnlock;i++){
    thumbs[i] = document.getElementById('thumb' + i);
    thumbs[i].addEventListener('click', ()=>{
      if (i < unlockedCount) window.open(thumbs[i].dataset.link, '_blank');
      else flashMessage('This site is locked — win a round to unlock it.');
    });
  }

  //setMessage('Watch the first card flip...');
  updateWinsDisplay();
}

function draw() {
  clear(); // transparent canvas
  // draw deck
  push();
  translate(deckX, deckY);
  for (let i = 0; i < deck.length; i++) {
    const dx = -i * offsetStep;
    const dy = -i * offsetStep;
    drawCardBack(dx, dy);
  }
  pop();

  // draw revealed/current card
  if (currentCard) {
    push();
    translate(deckX - 220, deckY);
    drawCardFace(currentCard, 0, 0, 1);
    pop();
  }

  if (anim) handleAnimation();
}

function drawCardBack(x, y) {
  push();
  translate(x, y);
  imageMode(CENTER);
  if (backImg) {
    // draw the image scaled to card size
    image(backImg, 0, 0, cardW, cardH, 5);
  } else {
    // fallback if image isn't loaded
    stroke(255);
    strokeWeight(2);
    fill(70, 120, 180);
    rectMode(CENTER);
    rect(0, 0, cardW, cardH, 5);
  }
  pop();
}



function drawCardFace(card, x, y, scaleX = 1) {
  push();
  translate(x, y);
  scale(scaleX, 1); // used during flip animations
  rectMode(CENTER);

  // === Card background ===
  stroke(0);
  strokeWeight(0);
  fill(255);
  rect(0, 0, cardW, cardH, 5);

  // === Card Value (Top Half) ===
  noStroke();
  textAlign(CENTER, CENTER);
  textSize(60);
  fill(card.faceColor);
  text(card.label, 0, -cardH / 4); // value near top half

  // === Suit Image (Bottom Half) ===
  imageMode(CENTER);
  if (suitImages[card.suit]) {
    image(suitImages[card.suit], 0, cardH / 4, 50, 50); // bottom half
  } else {
    // fallback if suit image missing
    textSize(40);
    text(card.suit, 0, cardH / 4);
  }

  pop();
}


function buildDeck(){
  deck = [];
  for (const s of suits) {
    for (const v of values) {
      deck.push({
        suit: s,
        label: v.label,
        value: v.value,
        faceColor: (s === '♥' || s === '♦') ? '#FF0000' : '#111',
      });
    }
  }
}

function shuffle(array, mutate=false){
  let arr = mutate ? array : array.slice();
  for (let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  if (!mutate) return arr;
}

function handleAnimation(){
  const now = millis();
  if (anim.type === 'initialMove') {
    const t = (now - anim.startTime) / anim.duration;
    const eased = 1 - pow(1 - constrain(t, 0, 1), 3);
    const drawX = lerp(deckX, deckX - 220, eased);
    push(); translate(drawX, deckY); drawCardBack(0, 0); pop();
    if (t >= 1) {
      anim = {type:'flipIn', startTime: now, duration: 600};
      currentCard = deck.pop();
      topIndex = deck.length - 1;
    }
  } else if (anim.type === 'flipIn') {
    const t = (now - anim.startTime) / anim.duration;
    const c = constrain(t, 0, 1);
    let scaleX = c < 0.5 ? map(c, 0, 0.5, 1, 0.01) : map(c, 0.5, 1, 0.01, 1);
    push();
    translate(deckX - 220, deckY);
    if (c < 0.5) drawCardBack(0,0); else drawCardFace(currentCard,0,0,scaleX);
    pop();
    if (c >= 1) anim = null;
  } else if (anim.type === 'flipNext') {
    const {startPos, endPos, cardObj, startTime, duration} = anim;
    const t = (now - startTime) / duration;
    const c = constrain(t, 0, 1);
    const mx = lerp(startPos.x, endPos.x, c);
    const my = lerp(startPos.y, endPos.y, c) - 20 * sin(PI * c);
    let scaleX = c < 0.5 ? map(c, 0, 0.5, 1, 0.01) : map(c, 0.5, 1, 0.01, 1);
    push();
    translate(mx, my);
    if (c < 0.5) drawCardBack(0,0); else drawCardFace(cardObj,0,0,scaleX);
    pop();
    if (c >= 1) {
      currentCard = cardObj; anim = null; busy = false;
      if (animCallback) { animCallback(); animCallback=null; }
    }
  }
}

function tryGuess(choice) {
  //if (busy) { flashMessage('Wait for animation.'); return; }
  if (!currentCard) return;
  if (deck.length === 0) { resetDeckAndShuffle(); return; }

  const nextCard = deck.pop();
  topIndex = deck.length - 1;
  busy = true;
  //setMessage('Revealing next card...');

  const prevCard = currentCard;

  const startPos = {x: deckX, y: deckY};
  const endPos = {x: deckX - 220, y: deckY};
  anim = {type:'flipNext', startPos, endPos, cardObj: nextCard, startTime: millis(), duration: 700};

  animCallback = () => evaluateGuess(choice, prevCard, nextCard);
}

function evaluateGuess(choice, oldCard, newCard) {
  let correct = false;
  if (newCard.value === oldCard.value) correct = false;
  else if (choice === 'higher') correct = newCard.value > oldCard.value;
  else correct = newCard.value < oldCard.value;

  if (correct) {
    wins++;
    setMessage('Correct! ' + newCard.label + newCard.suit);
    updateWinsDisplay();
    unlockNext();
  } else {
    wins = 0;
    //setMessage('Wrong guess — you lose. ' + newCard.label + newCard.suit);
    updateWinsDisplay();
    lockAllSites();
  }

  if (deck.length === 0) resetDeckAndShuffle();
}

function unlockNext(){
  if (unlockedCount < maxUnlock) {
    thumbs[unlockedCount].classList.remove('locked');
    thumbs[unlockedCount].classList.add('unlocked');
    unlockedCount++;
    setMessage('Unlocked site ' + unlockedCount + '!');
  }
}

function lockAllSites(){
  unlockedCount = 0;
  for (let i=0;i<maxUnlock;i++){
    thumbs[i].classList.remove('unlocked');
    thumbs[i].classList.add('locked');
  }
}

function resetDeckAndShuffle(){
  buildDeck();
  shuffle(deck, true);
  topIndex = deck.length - 1;
  currentCard = null;
  anim = {type:'initialMove', startTime: millis(), duration: 1000};
  lockAllSites();
  wins = 0;
  updateWinsDisplay();
}

function updateWinsDisplay(){
  document.getElementById('wins').innerText = wins;
}
function setMessage(msg){ document.getElementById('message').innerText = msg; }
function flashMessage(msg,t=1800){ setMessage(msg); setTimeout(()=>setMessage(''),t); }
</script>
</body>
</html>
